<!DOCTYPE html>
<html>

<head>
	<meta charset = 'utf-8'>
	<title>Eng-Chk Advanced Search</title>
	<link rel='stylesheet' href='style/advanced.css'>
</head>

<body>

	<div id='navBar'>
		Chukchansi Dictionary
	</div>
	<div id='searchPanel' class='noScrollbar'>
		search place for search thingz
	</div>
	<div id='searchResults' class='noScrollbar'>
		<div class='loading'>
			<div class='loading-diamond loading-left'></div>
			<div class='loading-diamond loading-right'></div>
		</div>
		<div class='search-result'>
			<div>
				<span class='search-result-title'><span class='highlight'>Black</span>berry</span>
				<span class='search-result-catg'>noun</span>
				<span class='search-result-translation'>maamil', maamila</span>
			</div>
			<div>
				<span class='search-result-sentence'>The <span class='highlight'>black</span>berries were very sweet.</span>
				<span class='search-result-sentence-translation'>Meejintaʔ k'uyuuk'ataʔ maamil'.</span>
			</div>
			<div>
				<span class='search-result-sentence'>I'm going to pick <span class='highlight-2'>black</span>berries soon.</span>
				<span class='search-result-sentence-translation'>Goobeʔ naʔ miʔin maamila.</span>
			</div>
		</div>
	</div>

	<!-- load dependencies -->
	<script type='text/javascript' src='script/dictionary.js'></script>
	<script type='text/javascript' src='data/en-ch-v12.js'></script>
	<script type='text/javascript' src='source/resources.js'></script>

	<script>

		//// WAVE 3 ////

		// 2.0 hrs: css cleanup and initial page layout
		// 1.0 hrs: css formatting for search results
		// 2.5 hrs: integrate fragment highlighting into search; set up search filter framework 

		//// TODO ////
		//

		/////////////////////////////////////////////////////////////////////

		//// ENV SETUP ////

		// debug
		let t1 = Date.now();
		// settings
		let langToggle = false;
		let searchSettings = {
			shiftDown: false,
			elem: undefined,
			HISTORY_MAX_LENGTH: 5,
			showHistory: false,
			showFilters: false,
			// history
			historyEng: [],
			historyChk: [],
			// catgs
			VALID_CATGS: ['all','noun','adjective','demonstrative','verb','auxiliary verb','pronoun','adverb','misc'],
			catgStrs: {
				'all':'SHOW ALL', 'none':'NONE', 'misc':'Misc',
				'noun':'Noun', 'adjective':'Adj', 'demonstrative':'Dem',
				'verb':'Verb','auxiliary verb':'Aux Verb','pronoun':'Pronoun','adverb':'Adv'
			},
			catgs: ['noun','adjective','demonstrative','verb','auxiliary verb','pronoun','adverb'],
			catgMisc: true,
			hasAllCatgs: () => {
				for (let catg of ['noun','adjective','demonstrative','verb','auxiliary verb','pronoun','adverb'])
					if (searchSettings.catgs.indexOf(catg) == -1)
						return false;
				return searchSettings.catgMisc;
			},
			hasNoCatgs: () => {
				for (let catg of ['noun','adjective','demonstrative','verb','auxiliary verb','pronoun','adverb'])
					if (searchSettings.catgs.indexOf(catg) != -1)
						return false;
				return !searchSettings.catgMisc;
			}
		};
		let soundSettings = {
			player: document.createElement('audio'),
			speakerAbbreviations: ['H',           'J'         ],
			speakerNames:         ['Holly Wyatt', 'Jane Wyatt']
		};

		// build dictionary
		let dictionary = new Dictionary(primary_eng, secondary_chk);
		dictionary.loadData( parse_en_ch_v12(tsv_en_ch_v12) );



		//// MEDIA RESOURCES ////

		// all resource interactions exclusively in lowercase to avoid problems with OS, proper nouns, bad naming
		let imageResources = {};
		let audioResources = {};

		// media indexing
		function indexResources () {
			const t0_resource_index = performance.now();
			let numResources = 0;
			// images: filename is word in english, with spaces if applicable
			for (let image of image_en_ch) {
				const word = [...image.matchAll(/(?<=\/)[^\/]+(?=\.)/g)][0][0].toLowerCase(); // use lookahead/lookbehind to isolate word in filename
				if (!word) continue;
				numResources++;
				if (!imageResources[word]) {
					imageResources[word] = [image];
				} else {
					imageResources[word].push(image);
				}
			}
			// audio: filename is word in chukchansi, an underscore, and a speaker ID
			for (let audio of audio_en_ch) {
				const word = [...audio.matchAll(/(?<=\/)[^\/]+(?=\_.+\.)/g)][0][0].toLowerCase(); // use lookahead/lookbehind to isolate word in filename
				if (!word) continue;
				numResources++;
				if (!audioResources[word]) {
					audioResources[word] = [audio];
				} else {
					audioResources[word].push(audio);
				}
			}
			console.log(numResources + ' media resources indexed in ' + (performance.now()-t0_resource_index) + 'ms. (' + image_en_ch.length + ' image, ' + audio_en_ch.length + ' audio)');
		}

		// media access
		function playSound (filename) {
			soundSettings.player.pause();
			soundSettings.player.src = 'source/' + filename;
			soundSettings.player.play();
		}
		function findIndexedImages (entry, word) {
			// rets array of image files for any synonym/form of "entry"
			// if "word" is specified, exact filename matches will be moved to the front of the array
			// needed in cases like "leeleʔhiy'", which means "book"/"school" in diff contexts that have very diff images
			if (Object.keys(imageResources).length == 0) console.warn('Attempted to access images before any were indexed.');
			let resources = [];
			word = word.toLowerCase();
			entry.forEachPrimaryForm(synonyms => {
				for (let form of synonyms) {
					form = form.toLowerCase();
					if (imageResources[form]) {
						for (const image of imageResources[form]) {
							(word && form==word) ? resources.unshift(image) : resources.push(image);
						}
					}
				}
			});
			entry.forEachSecondaryForm(synonyms => {
				for (let form of synonyms) {
					form = form.toLowerCase();
					if (imageResources[form]) {
						for (const image of imageResources[form]) {
							(word && form==word) ? resources.unshift(image) : resources.push(image);
						}
					}
				}
			});
			return resources;
		}
		function findIndexedAudio (entry, word) {
			// rets array of image files for any synonym/form of "entry"
			// if "word" is specified, exact filename matches will be moved to the front of the array
			// needed in cases like "leeleʔhiy'", which means "book"/"school" in diff contexts that have very diff images
			if (Object.keys(audioResources).length == 0) console.warn('Attempted to access audio before any was indexed.');
			let resources = [];
			word = word.toLowerCase();
			entry.forEachPrimaryForm(synonyms => {
				for (let form of synonyms) {
					form = form.toLowerCase();
					if (audioResources[form]) {
						for (const audio of audioResources[form]) {
							(word && form==word) ? resources.unshift(audio) : resources.push(audio);
						}
					}
				}
			});
			entry.forEachSecondaryForm(synonyms => {
				for (let form of synonyms) {
					form = form.toLowerCase();
					if (audioResources[form]) {
						for (const audio of audioResources[form]) {
							(word && form==word) ? resources.unshift(audio) : resources.push(audio);
						}
					}
				}
			});
			return resources;
		}



		/////////////////////////////////////////////////////////////////////

		//// CORE ////

		const subscriptFind = new RegExp('_([0-9]*)', 'ig'); // global, case-insensitive
		const subscriptReplace = '<sub>$1</sub>';
		const trySubscript = (text='') => text.replaceAll(subscriptFind, subscriptReplace);
		function capitalize (s) { s=s.toString().toLowerCase(); return (s[0]||'').toUpperCase()+s.substr(1); }


		

		// search result builders

		const DEFAULT_FILTERS = {
			//
		};

		let includeNonmatches = false; // add entries to search results even if they don't match the search frag
		let filters = {
			searchIn : { // select parts of entry to include/exclude from search
				title : true,
				titleTranslation : false,
				sentences : true,
				sentenceTranslations : false
			},
			catg : {
				// ['noun','adjective','demonstrative','verb','auxiliary verb','pronoun','adverb']
				active : ['adjective','demonstrative','verb','auxiliary verb','pronoun','adverb'],
				misc : true
			}
		};

		// let searchIn = { // select parts of entry to include/exclude from search
		// 	title : true,
		// 	titleTranslation : false,
		// 	sentences : true,
		// 	sentenceTranslations : false
		// };

        function buildSearchResult (entry,word,fragment='',fragFind,fragReplace) {
			const chkForm0 = entry.getSecondary(0);
			const chkForm1 = entry.getSecondary(1);
			const chkForms = chkForm1 ? (chkForm0[0]+', '+chkForm1[0]) : chkForm0[0];
			const engForm0 = entry.getPrimary().join(', ');

			// fetch entry data
			let title 				= !langToggle	? word			: chkForms;
			let titleTranslation	=  langToggle	? engForm0		: chkForms;
			let catg				= entry.catg;
			let synonyms			= entry.getPrimarySynonyms(word);
			// fetch sentence data
			let sentences			= [];
			let sentenceFormStrs	= [];
			entry.forEachSentence( (sentence,formNum) => {
				sentences.push(
					(!langToggle)
						? {base : sentence.primary, trans : sentence.secondary}
						: {base : sentence.secondary, trans : sentence.primary}
				);
				sentenceFormStrs.push(
					(dictionary._sLang.hasForm(catg,formNum[0]))
						? '(' + capitalize(dictionary._sLang.formStr(catg,formNum[0])) + ') '
						: ''
				);
			} );

			// try find/highlight search frag in entry data
			let highlightTitle = title.replaceAll(fragFind,fragReplace);
			let highlightTitleTranslation = titleTranslation.replaceAll(fragFind,fragReplace);
			// try find/highlight search frag in sentence data
			let highlightSentences = [];
			for (const sentence of sentences) {
				highlightSentences.push({
					base : sentence.base.replaceAll(fragFind,fragReplace),
					trans : sentence.trans.replaceAll(fragFind,fragReplace)
				});
			}

			// check if any part of entry contained frag
			let containsSearchFrag = false;
			if (highlightTitle != title && filters.searchIn.title) containsSearchFrag = true;
			if (highlightTitleTranslation != titleTranslation && filters.searchIn.titleTranslation) containsSearchFrag = true;
			for (let i = 0; i < sentences.length; i++) {
				if (highlightSentences[i].base != sentences[i].base && filters.searchIn.sentences) containsSearchFrag = true;
				if (highlightSentences[i].trans != sentences[i].trans && filters.searchIn.sentenceTranslations) containsSearchFrag = true;
			}
			let matchesCatg = false;
			if (filters.catg.active.indexOf(catg.toLowerCase()) != -1) {
				matchesCatg = true;
			}
			if (filters.catg.misc && filters.catg.active.indexOf(catg.toLowerCase()) != -1) {
				matchesCatg = true;
			}

			if (title == 'acorn, black oak') {
				console.log('READOUT: "acorn, black oak"');
				console.log(catg, filters.catg.active);
				console.log(filters.catg.active.indexOf(catg.toLowerCase()));
			}

			// if entry doesn't contain search frag, skip it
			const matchesFilters = containsSearchFrag && matchesCatg;
			if (fragment != '' && !matchesFilters && !includeNonmatches) return '';

			// else start building element
			let elemStr = '';

			elemStr += '<div class="search-result">';
				// first line is word, part of speech, translation
				elemStr += '<div>';
					elemStr += '<span class="search-result-title">' + trySubscript(highlightTitle) + '</span>';
					elemStr += '<span class="search-result-catg">' + catg + '</span>';
					elemStr += '<span class="search-result-translation">' + trySubscript(highlightTitleTranslation) + '</span>';
				elemStr += '</div>';
				// rest of lines are sentences
				for (let i = 0; i < sentences.length; i++) {
					elemStr += '<div>';
						elemStr += '<span class="search-result-sentence">' + highlightSentences[i].base + '</span>';
						elemStr += '<span class="search-result-sentence-translation">' + highlightSentences[i].trans + '</span>';
					elemStr += '</div>';
				}
				// synonyms
					//
			elemStr += '</div>';

			return elemStr;
		}

		function populateSearchResults (fragment = '') {
			const t0_populate = performance.now();
			let numWords = 0;

			const container = document.getElementById('searchResults');
			const fragFind    = !fragment ? undefined : (new RegExp('('+fragment+')', 'ig'));
			const fragReplace = !fragment ? undefined : '<span class="highlight">$1</span>';

			let elemStr = '';

			console.log(`Searching fragment "${fragment}"...`);
			dictionary.forEachWord((entry,word) => {
				const result =  buildSearchResult(entry,word,fragment,fragFind,fragReplace);
				elemStr += result;
				if (result != '') numWords++;
			});

			container.innerHTML = elemStr;
			console.log(`Built ${numWords} search results in ${performance.now()-t0_populate} ms.`);
		}







		window.addEventListener('keydown', (e) => {
			switch (e.key) {
			case '`': // [`] for dev action
				console.log('dev action');
				populateSearchResults('black');
				break;
			}
		});


		console.log('Load time: ' + (Date.now() - t1) + ' ms');

		/////////////////////////////////////////////////////////////////////
	</script>

</body>

</html>